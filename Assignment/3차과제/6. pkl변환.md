## .pkl을 변환해서 데이터베이스에 넣을수있는 형식으로 만든뒤에 데이터베이스에 연동

- SQLite 같은 데이터베이스를 사용할 경우, .pkl 파일은 필요하지 않죠...
- 데이터베이스는 데이터의 저장, 조회, 수정, 삭제 등의 작업을 효율적으로 수행할 수 있는 구조 및 기능을
- 제공하므로 별도의 파일을 사용할 필요가 없어요.
- 근데 이미 프로그램을 만들었으니까 기존의 프로그램 로직을 수정하지 않고
- .pkl파일을 통해서 데이터베이스와 관련된 함수 몇개랑 모듈하나를 추가해서 만들어보죠
- 일단 단어장이니까 오토커밋을 해도 괜찮을꺼같긴한데 회사가서 그러면 큰일나요 수동으로 하죠
  
```python
# 저는 sqlite를 쓸꺼에요 oracle은 빅프로젝트에 어울리기 때문이죠
# sqlite를 임포트합니다요

import sqlite3

# 데이터베이스 이름은 vocabulary로 하죠

DB_NAME = "vocabulary.db"
```
```python

def setup_database(): # 데이터베이스를 셋업하는 함수를 하나 만들죠
    conn = sqlite3.connect(DB_NAME) # 데이터베이스에 연결하는 객체를 conn으로 , DB_NAME은 파일이름변수에요
    cursor = conn.cursor() # 커서없이 실행하면 그냥 코드를 왕창 다 실행! 할수있어요 그러면 망하는거에요
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS vocabulary (
        word TEXT PRIMARY KEY,
        meanings TEXT
    )
    """) # execute는 sql명령어를 실행하는 코드!
# 안쪽코드는 if문을 섞어서 단어장테이블이 없으면 만드는 코드에요
# 존재하면 else문은 안써서 그냥 스킵이 되지요
# 그리고 딕셔너리니까 단어는 키값으로 뜻은 값으로 담으면 되겠죠? 중복값이니까?
    conn.commit() # 커밋(그냥 저장이죠 뭐)
    conn.close() # 열려있으면 리소스를 왕창 먹어서 닫아야죠

```
```python
def load_data(): # 요건 데이터를 받아와요
    conn = sqlite3.connect(DB_NAME) # 위랑 똑같아요
    cursor = conn.cursor() #  커서로 순차적으로 실행해야겠죠?
    cursor.execute("SELECT word, meaning FROM vocabulary") # execute는 실행하는 코드고 select로 vocabulary테이블에서 word열과 meaning열을 가져와요
    data = {row[0]: row[1].split(', ') for row in cursor.fetchall()} # 요 코드는 해석하자면

# 일단 단어장이니까 딕셔너리가 필요하니까 data에 딕셔너리값으로 변환시켜 넣고
# 스플릿을 통해서 , 기준으로 값을 따와요 ex) add면 더하다, 추가하다 이렇게 뜻이 여러개니까
# fetchall()은 모든 결과의 행을 반환하는 함수에용
# 저거를 풀어서 해석하면
#    rows = cursor.fetchall() 모든 결과를 행을 가져와서 rows에 할당하고
#    for row in rows: rows만큼 for문을 돌리는데 row는 그냥 내맘대로 이름정한거에요 
#    word = row[0] # 여기에 인덱싱을 하면 0행이 되서 word에 저장되고(파이썬은 0부터 끝-1까지니까)
#    meaning = row[1].split(', ') 뜻은 1행에 저장되는데 여러개니까 콤마를 기준으로 스플릿해서 일단 담습니다. 기본으로 리스트에 담기니까 그냥 넣으면 되요
#    data[word] = meaning # 그리고 담은 뜻들을 단어의 인덱싱에 포함을 하면 한단어에 여러개의 뜻이 담기게 됩니다. 

    conn.close() # 리소스먹으니까 닫아주고
    return data # 데이터를 리턴하죠
```
```python
def save_data(vocabulary): # 저장하는 함수를 만듭시다.
    conn = sqlite3.connect(DB_NAME) # 연결도 똑같이
    cursor = conn.cursor() # 커서도 똑같이

    for word, meaning in vocabulary.items(): # 이전에 썼던 for문이에요 items()는 get()과 다르게 다 가져올수있어요
        meanings = ', '.join(meaning) # 여러개의 뜻이 있을수도 있으니까 조인으로 콤마를 기준삼아서 뜻을 옆에다가 붙인변수를 meanings라고 할까요?
           
        # 해당 단어가 테이블에 있는지 확인해보는 코드
        cursor.execute("SELECT word FROM vocabulary WHERE word=?", (word,))
        result = cursor.fetchone()
        
        if result:  # 단어가 존재한다면?
            # 해당 레코드를 업데이트
            cursor.execute("UPDATE vocabulary SET meaning=? WHERE word=?", (meanings_str, word))
        else:  # 단어가 존재하지 않는다면
            # 새 레코드를 삽입
            cursor.execute("INSERT INTO vocabulary (word, meaning) VALUES (?, ?)", (word, meanings_str))

    # 근데 이걸 SQLite의 특수문법으로 쓸수있더라고요

    conn.commit() # 저장 
    conn.close() # 리소스먹으니까 닫기
```
