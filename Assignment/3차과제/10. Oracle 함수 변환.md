## 그럼 sqlite와 다르게 Oracle로 하면 어떻게 되지?
- 그래서 sqlite로 짠 코드가 있으니까 Oracle로 한번 바꾸는 시도를 해봤습니다.
  
```python
# 일단 sqlite와 마찬가지로 import를 해야겠지요?
# sqlite은 제거해줬습니다.
import cx_Oracle
```

<img src="https://github.com/fightmeat/photos/blob/b1e55141cf78066b31ec5a7cdb3640a5623b58b3/scott.png" width="600" height="400"/>


```python

# Oracle 연결 문자열: "scott/1234@localhost:1521/xe"
DB_CONNECTION_STRING = "scott/1234@localhost:1521/xe"

def setup_database():
    conn = cx_Oracle.connect(DB_CONNECTION_STRING)
    cursor = conn.cursor()
    try:
        cursor.execute("""
        CREATE TABLE vocabulary (
            word VARCHAR2(45) PRIMARY KEY,
            meanings VARCHAR2(1000)
        )
        """)
    except cx_Oracle.DatabaseError as e:
        error, = e.args
        if error.code == 955:  # Table already exists error
            pass
        else:
            raise  # Reraise the exception if it's a different error
    conn.commit()
    conn.close()

# 코드 구성은 아까 sqlite와 똑같아요
# 영어 사전에서 제일 긴 단어는 Pneumonoultramicroscopicsilicovolcanoconiosis로 45글자 그래서 글씨수제한을 45개로 걸고 뜻은 걍 1000자까지 적었어요
# NVARCHAR2를 쓰면 영어말고 막 아랍어 이런거도 쓸수있데요 국제 문자 집합을 위한 데이터 타입이래요 아무튼 그렇다고요 단어니까 키고 문자는 걍 쓰면되죠


def load_data():
    conn = cx_Oracle.connect(DB_CONNECTION_STRING)
    cursor = conn.cursor()
    cursor.execute("SELECT word, meanings FROM vocabulary")
    data = {row[0]: row[1].split(', ') for row in cursor.fetchall()}
    conn.close()
    return data

def save_data(vocabulary):

    conn = cx_Oracle.connect(DB_CONNECTION_STRING)
    cursor = conn.cursor()

# 근데 아까는 여기서 전용문법을 썼는데 오라클은 없어서 이렇게 길게 써야해요
# 대충 Oracle 데이터베이스의 vocabulary 테이블에 단어를 추가하거나 업데이트하는데
# 주어진 단어가 이미 테이블에 있으면 뜻을 업데이트하고, 없으면 새로운 단어와 뜻을 삽입합니다.
# MERGE 명령문을 쓰는 작업이에요

    for word, meanings in vocabulary.items():
        meanings_str = ', '.join(meanings)
        cursor.execute(
            "MERGE INTO vocabulary USING DUAL ON (word = :word) "
            "WHEN MATCHED THEN UPDATE SET meanings = :meanings "
            "WHEN NOT MATCHED THEN INSERT (word, meanings) "
            "VALUES (:word, :meanings)", 
            {'word': word, 'meanings': meanings_str}
        )


    conn.commit()
    conn.close()

```
